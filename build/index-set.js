eval("var define, require;\n\n(function () {\n  var registry = {}, seen = {};\n\n  define = function (name, deps, callback) {\n    registry[name] = { deps: deps, callback: callback };\n  };\n\n  require = function (name) {\n    if (seen[name]) { return seen[name]; }\n    seen[name] = {};\n\n    var mod = registry[name],\n        deps = mod.deps,\n        callback = mod.callback,\n        reified = [],\n        exports;\n\n    for (var i=0, l=deps.length; i<l; i++) {\n      if (deps[i] === \'exports\') {\n        reified.push(exports = {});\n      } else {\n        reified.push(require(deps[i]));\n      }\n    }\n\n    var value = callback.apply(this, reified);\n    return seen[name] = exports || value;\n  };\n})();\n//# sourceURL=loader.js");
eval("define(\"index-set\", \n  [\"index-set/addition\",\"index-set/removal\",\"index-set/env\",\"index-set/coding\",\"index-set/enumeration\",\"index-set/queries\",\"index-set/indexes\",\"index-set/range_start\",\"index-set/observing\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __dependency9__, __exports__) {\n    \"use strict\";\n    var addIndex = __dependency1__.addIndex;\n    var addIndexes = __dependency1__.addIndexes;\n    var addIndexesInRange = __dependency1__.addIndexesInRange;\n    var removeIndex = __dependency2__.removeIndex;\n    var removeIndexes = __dependency2__.removeIndexes;\n    var removeIndexesInRange = __dependency2__.removeIndexesInRange;\n    var ENV = __dependency3__[\"default\"];\n    var serialize = __dependency4__.serialize;\n    var deserialize = __dependency4__.deserialize;\n    var forEach = __dependency5__.forEach;\n    var map = __dependency5__.map;\n    var reduce = __dependency5__.reduce;\n    var some = __dependency5__.some;\n    var every = __dependency5__.every;\n    var forEachRange = __dependency5__.forEachRange;\n    var someRange = __dependency5__.someRange;\n    var everyRange = __dependency5__.everyRange;\n    var equals = __dependency6__.equals;\n    var containsIndex = __dependency6__.containsIndex;\n    var containsIndexes = __dependency6__.containsIndexes;\n    var containsIndexesInRange = __dependency6__.containsIndexesInRange;\n    var intersectsIndex = __dependency6__.intersectsIndex;\n    var intersectsIndexes = __dependency6__.intersectsIndexes;\n    var intersectsIndexesInRange = __dependency6__.intersectsIndexesInRange;\n    var indexLessThanIndex = __dependency7__.indexLessThanIndex;\n    var indexLessThanOrEqualToIndex = __dependency7__.indexLessThanOrEqualToIndex;\n    var indexGreaterThanIndex = __dependency7__.indexGreaterThanIndex;\n    var indexGreaterThanOrEqualToIndex = __dependency7__.indexGreaterThanOrEqualToIndex;\n    var rangeStartForIndex = __dependency8__[\"default\"];\n    var trigger = __dependency9__.trigger;\n    var on = __dependency9__.on;\n    var off = __dependency9__.off;\n    var destroy = __dependency9__.destroy;\n\n    var slice = Array.prototype.slice,\n        toString = Object.prototype.toString,\n        T_NUMBER = \'[object Number]\',\n        END_OF_SET = ENV.END_OF_SET;\n\n    /**\n      @private\n      Routes a function call from the overloaded method to the\n      concrete method call by doing argument checking.\n\n      @method invokeConcreteMethodFor\n      @param indexSet {IndexSet}\n      @param fnName\n     */\n    function invokeConcreteMethodFor(indexSet, fnName, args) {\n      if (args.length === 1) {\n        if (args[0] instanceof IndexSet) {\n          return indexSet[fnName + \"Indexes\"](args[0]);\n        } else if (toString.call(args[0]) === T_NUMBER) {\n          return indexSet[fnName + \"Index\"](args[0]);\n        }\n      } else if (args.length === 2) {\n        return indexSet[fnName + \"IndexesInRange\"](args[0], args[1]);\n      }\n    }\n\n    /**\n      An IndexSet represents a collection of unique unsigned integers,\n      known as **indexes** because of the way they are used. This collection\n      is referred to as an **index set**.\n\n      You use index sets in your code to store indexes into some other\n      data structure. For example, given an array, you could use an index\n      set to identify a subset of objects in that array.\n\n      You should not use index sets to store an arbitrary collection of\n      integer values because index sets store indexes as sorted ranges.\n      This makes them more efficient than storing a collection of individual\n      integers. It also means that each index value can only appear once in\n      the index set.\n\n      Index sets are a concept from [Cocoa][1], and are useful in managing\n      ordered collections, such as views or data sets.\n\n      ### Implementation Notes\n\n      The internal data structure is a jump list, where the following rules\n      indicate how to find ranges:\n\n      - a positive integer indicates a filled range\n      - a negative integer indicates a hole\n      - `0` indicates the end of the set\n\n      In addition, there are search accelerator for increasing the performance\n      of insertion and querying. These values are stored in the jump list\n      and indicate the start of the nearest range.\n\n      **NOTE**: Infinite ranges are currently unsupported.\n\n      [1]: http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/Collections/Articles/ \"Cocoa Collections\"\n\n      @class IndexSet\n     */\n    function IndexSet() {\n      var args = slice.call(arguments);\n\n      // Optimize creating a cloned index set\n      if (args.length == 1 && args[0] instanceof IndexSet) {\n        var source = args[0];\n\n        // Copy over properties rather than\n        // manually adding them.\n        //\n        // This results in a faster clone for\n        // very large index sets.\n        this.__ranges__ = source.__ranges__.slice();\n        this.length = source.length;\n        this.firstIndex = source.firstIndex;\n        this.lastIndex = source.lastIndex;\n\n      } else {\n        this.__ranges__ = [END_OF_SET];\n        invokeConcreteMethodFor(this, \'add\', args);\n      }\n    };\n\n    IndexSet.prototype = {\n\n      /**\n        The size of the indicates. This is the number\n        of indexes currently stored in the set.\n\n        @property length\n        @readOnly\n        @type Number\n        @default 0\n       */\n      length: 0,\n\n      /**\n        The first index in the set, or -1 if there\n        are no indexes in the set.\n\n        @property firstIndex\n        @readOnly\n        @type Number\n        @default -1\n       */\n      firstIndex: -1,\n\n      /**\n        The last index in the set, or -1 if there\n        are no indexes in the set.\n\n        @property lastIndex\n        @readOnly\n        @type Number\n        @default -1\n       */\n      lastIndex: -1,\n\n      // .............................................\n      // Mutable IndexSet methods\n      //\n\n      /**\n        Add a single index to the `IndexSet`.\n        This index must be a natural number.\n\n        @method addIndex\n        @chainable\n        @param index {Number}\n       */\n      addIndex: function (index) {\n        addIndex(this, index);\n        return this;\n      },\n\n      /**\n        Add a collection of indexes to the `IndexSet`.\n\n        @method addIndexes\n        @chainable\n        @param indexSet {IndexSet}\n       */\n      addIndexes: function (indexSet) {\n        addIndexes(this, indexSet);\n        return this;\n      },\n\n      /**\n        Add a range of indexes to the `IndexSet`.\n        The range values provided indicate the start\n        of the range and the length of the range.\n\n        @method addIndexesInRange\n        @chainable\n        @param rangeStart  {Number} A natural number that indicates the start of the range to add.\n        @param rangeLength {Number} A natural number that indicates the length of the range.\n       */\n      addIndexesInRange: function (rangeStart, rangeLength) {\n        addIndexesInRange(this, rangeStart, rangeLength);\n        return this;\n      },\n\n      /**\n        Remove a single index from the `IndexSet`.\n        The index must be a natural number.\n\n        @method removeIndex\n        @chainable\n        @param index {Number}\n       */\n      removeIndex: function (index) {\n        removeIndex(this, index);\n        return this;\n      },\n\n      /**\n        Remove a collection of indexes from the `IndexSet`.\n\n        @method removeIndexes\n        @chainable\n        @param indexSet {IndexSet}\n       */\n      removeIndexes: function (indexSet) {\n        removeIndexes(this, indexSet);\n        return this;\n      },\n\n      /**\n        Remove all indexes stored in the index set.\n\n        @method removeAllIndexes\n        @chainable\n       */\n      removeAllIndexes: function () {\n        trigger(this, \'length:before\',      0);\n        trigger(this, \'firstIndex:before\', -1);\n        trigger(this, \'lastIndex:before\',  -1);\n\n        this.__ranges__ = [0];\n        this.length     = 0;\n        this.firstIndex = -1;\n        this.lastIndex  = -1;\n\n        trigger(this, \'length:change\',      0);\n        trigger(this, \'firstIndex:change\', -1);\n        trigger(this, \'lastIndex:change\',  -1);\n\n        return this;\n      },\n\n      /**\n        Remove a range of indexes from the `IndexSet`.\n        The range values provided indicate the start\n        of the range and the length of the range.\n\n        @method addIndexesInRange\n        @chainable\n        @param rangeStart  {Number} A natural number that indicates the start of the range to remove.\n        @param rangeLength {Number} A natural number that indicates the length of the range.\n       */\n      removeIndexesInRange: function (rangeStart, rangeEnd) {\n        removeIndexesInRange(this, rangeStart, rangeEnd);\n        return this;\n      },\n\n      // .............................................\n      // Set membership\n      //\n\n      /**\n        @method containsIndex\n        @param index {Number}\n        @return {Boolean} Whether or not\n          the set contains the index passed in.\n       */\n      containsIndex: function (index) {\n        return containsIndex(this, index);\n      },\n\n      /**\n        @method containsIndexes\n        @param indexSet {IndexSet}\n        @return {Boolean} Whether or not\n          the set contains the index set.\n       */\n      containsIndexes: function (indexSet) {\n        return containsIndexes(this, indexSet);\n      },\n\n      /**\n        @method containsIndexes\n        @param rangeStart  {Number}\n        @param rangeLength {Number}\n        @return {Boolean} Whether or not\n          the set contains the range of indexes passed in.\n       */\n      containsIndexesInRange: function (rangeStart, rangeLength) {\n        return containsIndexesInRange(this, rangeStart, rangeLength);\n      },\n\n      /**\n        @method intersectsIndex\n        @param index {Number}\n        @return {Boolean} Whether or not\n          the index intersects any indexes in the set.\n       */\n      intersectsIndex: function (index) {\n        return intersectsIndex(this, index);\n      },\n\n      /**\n        @method intersectsIndexes\n        @param indexSet {IndexSet}\n        @return {Boolean} Whether or not\n          any indexes in the passed set are included in the set.\n       */\n      intersectsIndexes: function (indexSet) {\n        return intersectsIndexes(this, indexSet);\n      },\n\n      /**\n        @method intersectsIndexesInRange\n        @param rangeStart  {Number}\n        @param rangeLength {Number}\n        @return {Boolean} Whether or not\n          the range contains any indexes in the set.\n       */\n      intersectsIndexesInRange: function (rangeStart, rangeEnd) {\n        return intersectsIndexesInRange(this, rangeStart, rangeEnd);\n      },\n\n      // .............................................\n      // Getting indexes\n      //\n\n      /**\n        @method indexGreaterThanIndex\n        @param index {Number}\n        @return {Number} The first index in the set that is\n          greater than the index provided.\n       */\n      indexGreaterThanIndex: function (index) {\n        return indexGreaterThanIndex(this, index);\n      },\n\n      /**\n        @method indexGreaterThanOrEqualToIndex\n        @param index {Number}\n        @return {Number} The first index in the set that is\n          greater than the index provided, or the index\n          if it is within the set.\n       */\n      indexGreaterThanOrEqualToIndex: function (index) {\n        return indexGreaterThanOrEqualToIndex(this, index);\n      },\n\n      /**\n        @method indexLessThanIndex\n        @param index {Number}\n        @return {Number} The first index in the set that is\n          less than the index provided.\n       */\n      indexLessThanIndex: function (index) {\n        return indexLessThanIndex(this, index);\n      },\n\n      /**\n        @method indexLessThanOrEqualToIndex\n        @param index {Number}\n        @return {Number} The first index in the set that is\n          less than the index provided, or the index\n          if it is within the set.\n       */\n      indexLessThanOrEqualToIndex: function (index) {\n        return indexLessThanOrEqualToIndex(this, index);\n      },\n\n      /**\n        For a given index, this will return the index\n        that indicates the start of the range the index\n        is contained in. Note that this range may be\n        a filled range or a hole.\n\n        @private\n        @method rangeStartForIndex\n        @param index {Number}\n        @return Number\n       */\n      rangeStartForIndex: function (index) {\n        return rangeStartForIndex(this, index);\n      },\n\n      // .............................................\n      // Simplified JS interface\n      //\n\n      /**\n        Add indexes to the index set. This method will\n        take a single index, a index range, or an `IndexSet`.\n\n        @method add\n        @chainable\n       */\n      add: function () {\n        invokeConcreteMethodFor(this, \'add\', slice.call(arguments));\n        return this;\n      },\n\n      /**\n        Remove indexes the index set. This method will\n        take a single index, a index range, or an `IndexSet`.\n\n        @method remove\n        @chainable\n       */\n      remove: function () {\n        invokeConcreteMethodFor(this, \'remove\', slice.call(arguments));\n        return this;\n      },\n\n      /**\n        @method intersects\n        @return {Boolean} Whether the indexes provided\n           intersect the IndexSet.\n       */\n      intersects: function () {\n        return invokeConcreteMethodFor(this, \'intersects\', slice.call(arguments));\n      },\n\n      /**\n        @method contains\n        @return {Boolean} Whether the IndexSet contains\n           the provided indexes.\n       */\n      contains: function () {\n        return invokeConcreteMethodFor(this, \'contains\', slice.call(arguments));\n      },\n\n      /**\n        @method equals\n        @param indexSet {IndexSet}\n          The IndexSet to test against.\n        @return {Boolean} Whether the two IndexSets\n          are equivalent.\n       */\n      equals: function (indexSet) {\n        return equals(this, indexSet);\n      },\n\n      /**\n        @method indexBefore\n        @param index {Number} The index start searching from.\n        @return {Number} The first index in the set\n          before the given index.\n       */\n      indexBefore: function (index) {\n        return indexLessThanIndex(this, index);\n      },\n\n      /**\n        @method indexAfter\n        @param index {Number} The index start searching from.\n        @return {Number} The first index in the set\n          after the given index.\n       */\n      indexAfter: function (index) {\n        return indexGreaterThanIndex(this, index);\n      },\n\n      /**\n        Allows the garbage collector to reclaim memory of the\n        index set.\n\n        @method destroy\n       */\n      destroy: function () {\n        destroy(this);\n        this.removeAllIndexes();\n      },\n\n      // .............................................\n      // Copying\n      //\n\n      /**\n        @method copy\n        @return {IndexSet} A copy of the set.\n       */\n      copy: function () {\n        return new IndexSet(this);\n      },\n\n      // .............................................\n      // Coding\n      //\n\n      /**\n        @method serialize\n        @return {String} The set serialized as a string.\n       */\n      serialize: function () {\n        return serialize(this);\n      },\n\n      // .............................................\n      // Observing\n      //\n\n      /**\n        Listen to property changes on the IndexSet\n        by adding an event listener.\n\n        For get notifications when the length\n        of the IndexSet will change, the event\n        is `length:change`. To be notified before\n        the property changes, the event is\n        `length:before`:\n\n            var set = new IndexSet();\n            set.on(\'length:before\', null, function (set, event, length) {\n              console.log(\'The IndexSet will have \' + length + \' indexes.\');\n            });\n            set.on(\'length:change\', null, function (set, event, length) {\n              console.log(\'The IndexSet now has \' + length + \' indexes.\');\n            });\n\n        @method on\n        @param key {String}\n          The event to listen to.\n        @param target {*}\n          The target object to scope the method.\n        @param method {Function}\n          The function to be called when the event\n          gets triggered.\n       */\n      on: function (key, target, method) {\n        return on(this, key, target, method);\n      },\n\n      /**\n        Remove an event listener. To remove a\n        listener, this should be called with the\n        same arguments as `on`.\n\n        @method on\n        @param key {String}\n          The event to stop listening to.\n        @param target {*}\n          The target object used to scope the method.\n        @param method {Function}\n          The function that was used to\n          listen to events.\n       */\n      off: function (key, target, method) {\n        return off(this, key, target, method);\n      },\n\n      // .............................................\n      // Enumeration\n      //\n\n      /**\n        Loop over every index in this set.\n        This is compatible with ECMAScript\n        implementations.\n\n        @method forEach\n        @param fn    {Function} The function to call\n          for each iteration of the loop\n        @param scope {*} The scope to call the function with.\n       */\n      forEach: function (fn, scope) {\n        forEach(this, fn, scope);\n      },\n\n      /**\n        @method map\n        @param fn\n        @param scope {*} The scope to call the function with.\n       */\n      map: function (fn, scope) {\n        return map(this, fn, scope);\n      },\n\n      /**\n        @method reduce\n        @param fn\n        @param [initialValue] {*} The initial value to\n          call the reducer function with\n       */\n      reduce: function (fn, initialValue) {\n        var args = slice.call(arguments);\n        args.unshift(this);\n        return reduce.apply(null, args);\n      },\n\n      /**\n        @method some\n        @param fn\n        @param scope {*} The scope to call the function with.\n        @return {Boolean} Whether any of the\n          indexes in the set satisfied the\n          function provided.\n       */\n      some: function (fn, scope) {\n        return some(this, fn, scope);\n      },\n\n      /**\n        @method every\n        @param fn\n        @param scope {*} The scope to call the function with.\n        @return {Boolean} Whether all of the\n          indexes in the set satisfied the\n          function provided.\n       */\n      every: function (fn, scope) {\n        return every(this, fn, scope);\n      },\n\n      /**\n        Loop over every range in this set.\n\n        @method forEachRange\n        @param fn    {Function} The function to call\n          for each iteration of the loop\n        @param scope {*} The scope to call the function with.\n       */ \n      forEachRange: function (fn, scope) {\n        forEachRange(this, fn, scope);\n      },\n\n      /**\n        @method someRange\n        @param fn\n        @param scope {*} The scope to call the function with.\n        @return {Boolean} Whether any of the\n          ranges in the set satisfied the\n          function provided.\n       */\n      someRange: function (fn, scope) {\n        someRange(this, fn, scope);\n      },\n\n      /**\n        @method everyRange\n        @param fn\n        @param scope {*} The scope to call the function with.\n        @return {Boolean} Whether all of the\n          ranges in the set satisfied the\n          function provided.\n       */\n      everyRange: function (fn, scope) {\n        everyRange(this, fn, scope);\n      }\n    };\n\n    /**\n      @method deserialize\n      @static\n      @param string {String} The string to deserialize.\n      @param strict {Boolean} Whether errors should be thrown if the serialization is invalid.\n      @return {IndexSet} The string represented as an IndexSet.\n     */\n    IndexSet.deserialize = function (string, strict) {\n      return deserialize(new IndexSet(), string, strict);\n    };\n\n    IndexSet.ENV = ENV;\n\n    __exports__[\"default\"] = IndexSet;\n  });//# sourceURL=index-set.js");
eval("define(\"index-set/addition\", \n  [\"index-set/range_start\",\"index-set/enumeration\",\"index-set/env\",\"index-set/hint\",\"index-set/observing\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {\n    \"use strict\";\n    var rangeStartForIndex = __dependency1__[\"default\"];\n    var forEachRange = __dependency2__.forEachRange;\n    var ENV = __dependency3__[\"default\"];\n    var addHintFor = __dependency4__[\"default\"];\n    var set = __dependency5__.set;\n\n    var END_OF_SET = ENV.END_OF_SET;\n\n    /**\n      @private\n      @method addIndex\n      @param  indexSet {IndexSet} The target index set to add the index to.\n      @param  index    {Number}   The index to add to the target index set.\n     */\n    function addIndex(indexSet, index) {\n      addIndexesInRange(indexSet, index, 1);\n    }\n\n    function addRange(rangeStart, rangeLength) {\n      addIndexesInRange(this, rangeStart, rangeLength);\n    }\n\n    /**\n      @private\n      @method addIndexes\n      @param  indexSet {IndexSet} The target index set to add the indexes to.\n      @param  indexes  {IndexSet} The indexes to add to the target index set.\n     */\n    function addIndexes(indexSet, indexes) {\n      forEachRange(indexes, addRange, indexSet);\n    }\n\n    /**\n      @private\n      @method addIndexesInRange\n      @param  indexSet    {IndexSet}\n      @param  rangeStart  {Number}\n      @param  rangeLength {Number}\n     */\n    function addIndexesInRange(indexSet, rangeStart, rangeLength) {\n      var lastIndex = indexSet.lastIndex + 1,\n          ranges    = indexSet.__ranges__,\n          cursor, next, delta;\n\n      // The start of the range we\'re adding is the same as the\n      // last index of the set\n      if (rangeStart === lastIndex) {\n\n        // We have an empty index set and are adding from 0;\n        // Mark the first index in our index set as a filled range\n        // until the end of this range\n        if (rangeStart === END_OF_SET) {\n          ranges[lastIndex] = lastIndex = rangeLength;\n          delta = rangeLength;\n        } else {\n          // Find the start and end of the range that ends with\n          // the last index in the index set\n          cursor = rangeStartForIndex(indexSet, rangeStart - 1);\n          next   = ranges[cursor];\n\n          // We found a range in the set\n          if (next > 0) {\n            // Calculate the change in length\n            delta = rangeStart - lastIndex + rangeLength;\n\n            // Clean up the previous lastIndex\n            delete ranges[lastIndex];\n            // and set the start of the set to be the end\n            // of the new range\n            ranges[cursor] = lastIndex = rangeStart + rangeLength;\n            rangeStart = cursor;\n\n          // The previous range was not in the set;\n          // Append the set to the end of the set\n          } else {\n            ranges[lastIndex] = lastIndex = rangeStart + rangeLength;\n            delta = rangeLength;\n          }\n        }\n\n        // Mark the last index in the range as the end of the set\n        ranges[lastIndex] = END_OF_SET;\n        set(indexSet, \'lastIndex\', lastIndex - 1);\n        set(indexSet, \'length\',    indexSet.length + delta);\n\n        rangeLength = lastIndex - rangeStart;\n\n      // The start of the range being added starts beyond\n      // the current last index of the set.\n      } else if (rangeStart > lastIndex) {\n        // Mark from the current end of the set to the start\n        // of this range as a hole.\n        ranges[lastIndex] = 0 - rangeStart;\n        // Mark the start of the range as a filled until the\n        // end of the range.\n        ranges[rangeStart] = rangeStart + rangeLength;\n        // Mark the end of the index set.\n        ranges[rangeStart + rangeLength] = END_OF_SET;\n\n        set(indexSet, \'lastIndex\', rangeStart + rangeLength - 1);\n        set(indexSet, \'length\',    indexSet.length + rangeLength);\n\n        delta = rangeLength;\n\n        // The affected range for hinting goes from\n        // the start of the range to the end of the set.\n        rangeLength = rangeStart + rangeLength - lastIndex;\n        rangeStart  = lastIndex;\n\n      // Merge the range into the set.\n      } else {\n        // Find the nearest starting range\n        cursor = rangeStartForIndex(indexSet, rangeStart);\n        next   = ranges[cursor];\n\n        var rangeEnd = rangeStart + rangeLength;\n        delta = 0;\n\n        // The range boundary that we found was the same as\n        // the start of the range being inserted;\n        // jump back to the range before the indicated hole\n        if (rangeStart > 0 && cursor === rangeStart && next <= 0) {\n          cursor = rangeStartForIndex(indexSet, rangeStart - 1);\n          next   = ranges[cursor];\n        }\n\n        // The start of the range we found is a hole\n        if (next < 0) {\n          // Set the end of the hole to be the start of\n          // range being added.\n          ranges[cursor] = 0 - rangeStart;\n\n          // The hole extends beyond the range being added\n          if (Math.abs(next) > rangeEnd) {\n            // Mark the start and end of the set.\n            ranges[rangeStart] = 0 - rangeEnd;\n            ranges[rangeEnd] = next;\n\n          // The end of the range has already been taken care of\n          } else {\n            ranges[rangeStart] = next;\n          }\n\n        // The start of the range we found was filled\n        } else {\n          // Normalize variables so we can merge ranges together\n          rangeStart = cursor;\n          if (next > rangeEnd) {\n            rangeEnd = next;\n          }\n        }\n\n        // Walk ranges until we end up past the end of the\n        // range being added\n        var value;\n        cursor = rangeStart;\n        while (cursor < rangeEnd) {\n          // Find the next boundary location.\n          value = ranges[cursor];\n\n          // We reached the end of the set;\n          // Mark the end of the range as the end of the set\n          if (value === END_OF_SET) {\n            ranges[rangeEnd] = END_OF_SET;\n            next = rangeEnd;\n            delta += rangeEnd - cursor;\n\n          } else {\n            next = Math.abs(value);\n\n            // The start of the next range is after\n            // the end of the range being added\n            if (next > rangeEnd) {\n              ranges[rangeEnd] = value;\n              next = rangeEnd;\n            }\n\n            // The range has been added;\n            // Add to the delta if we have any new indexes\n            if (value < 0) {\n              delta += next - cursor;\n            }\n          }\n\n          // Delete the range boundary.\n          delete ranges[cursor];\n\n          // Iterate to the next range boundary in the set\n          cursor = next;\n        }\n\n        // The cursor should be the end of range being added.\n        // If the range following the cursor is in the index set,\n        // clean up the redundant boundary\n        cursor = ranges[rangeEnd];\n        if (cursor > 0) {\n          delete ranges[rangeEnd];\n          rangeEnd = cursor;\n        }\n\n        // Finally, mark the beginning of the range as filled\n        ranges[rangeStart] = rangeEnd;\n\n        if (rangeEnd > lastIndex) {\n          set(indexSet, \'lastIndex\', rangeEnd - 1);\n        }\n\n        // Adjust the length\n        set(indexSet, \'length\', indexSet.length + delta);\n\n        // Compute the hint range\n        rangeLength = rangeEnd - rangeStart;\n      }\n\n      // The firstIndex of the set might\'ve changed\n      if (delta > 0) {\n        cursor = ranges[0];\n\n        // No indexes for there to be a firstIndex\n        if (cursor === END_OF_SET) {\n          set(indexSet, \'firstIndex\', -1);\n        // We have a filled range starting at 0\n        } else if (cursor > 0) {\n          set(indexSet, \'firstIndex\', 0);\n        // Use the pointer to the first filled range\n        } else {\n          set(indexSet, \'firstIndex\', Math.abs(cursor));\n        }\n      }\n\n      addHintFor(indexSet, rangeStart, rangeLength);\n    }\n\n    __exports__.addIndex = addIndex;\n    __exports__.addIndexes = addIndexes;\n    __exports__.addIndexesInRange = addIndexesInRange;\n  });//# sourceURL=index-set/addition.js");
eval("define(\"index-set/range_start\", \n  [\"index-set/env\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    var ENV = __dependency1__[\"default\"];\n\n    function rangeStartForIndex(indexSet, index) {\n      var ranges = indexSet.__ranges__,\n          lastIndex = indexSet.lastIndex + 1,\n          rangeStart,\n          next,\n          hint;\n\n      // If the index is the lastIndex or past it,\n      // then the last index is the start of the range.\n      if (index >= lastIndex) {\n        return lastIndex;\n      }\n\n      // The index provided is a range boundary\n      if (Math.abs(ranges[index]) > index) {\n        return index;\n      }\n\n      // Lookup the hint index and see if we have\n      // a hit where the start of the range is\n      hint = index - (index % ENV.HINT_SIZE);\n      rangeStart = ranges[hint];\n\n      // If the hint was negative, we hit a boundary;\n      // if the hint was greater than the index we requested,\n      // we need to backtrack from the hint index to\n      // find the start of the range.\n      if (rangeStart < 0 || rangeStart > index) {\n        rangeStart = hint;\n      }\n\n      next = ranges[rangeStart];\n\n      // We are searching in the middle of a range;\n      // recurse to find the starting index of this range\n      if (typeof next === \"undefined\") {\n        if (typeof rangeStart !== \"undefined\") {\n          rangeStart = rangeStartForIndex(indexSet, rangeStart);\n        } else {\n          rangeStart = 0;\n        }\n        next = Math.abs(ranges[rangeStart]);\n\n      // We don\'t care whether we\'re in a hole or not\n      } else {\n        next = Math.abs(next);\n      }\n\n      // If there was a malformed index set, where there\n      // were filled indexes, but no items in the set,\n      // make that known and clean up the index set\n      if (next === ENV.END_OF_SET) {\n        indexSet.removeAllIndexes();\n        return -1;\n      }\n\n      // Step through the ranges in our set until we\n      // find the start of range that contains our index\n      while (next < index) {\n        rangeStart = next;\n        next = Math.abs(ranges[rangeStart]);\n      }\n\n      return rangeStart;\n    }\n\n    __exports__[\"default\"] = rangeStartForIndex;\n  });//# sourceURL=index-set/range_start.js");
eval("define(\"index-set/env\", \n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    __exports__[\"default\"] = {\n      // The size of the space where we mark hints\n      // to increase the performance of `rangeStartForIndex`.\n      HINT_SIZE: 256,\n\n      // A constant indicating the end of the IndexSet\n      END_OF_SET: 0\n    };\n  });//# sourceURL=index-set/env.js");
eval("define(\"index-set/enumeration\", \n  [\"index-set/env\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    var ENV = __dependency1__[\"default\"];\n\n    var END_OF_SET = ENV.END_OF_SET;\n\n    function forEach(indexSet, fn, scope) {\n      var ranges = indexSet.__ranges__,\n          cursor = 0,\n          next   = ranges[cursor];\n\n      if (typeof scope === \"undefined\") {\n        scope = null;\n      }\n\n      while (next !== END_OF_SET) {\n        if (next > 0) {\n          for (var i = cursor; i < next; i++) {\n            fn.call(scope, i, indexSet);\n          }\n        }\n        cursor = Math.abs(next);\n        next = ranges[cursor];\n      }\n    }\n\n    function map(indexSet, fn, scope) {\n      var ranges = indexSet.__ranges__,\n          cursor = 0,\n          next   = ranges[cursor],\n          result = [];\n\n      if (typeof scope === \"undefined\") {\n        scope = null;\n      }\n\n      while (next !== END_OF_SET) {\n        if (next > 0) {\n          for (var i = cursor; i < next; i++) {\n            result.push(fn.call(scope, i, indexSet));\n          }\n        }\n        cursor = Math.abs(next);\n        next = ranges[cursor];\n      }\n      return result;\n    }\n\n    function reduce(indexSet, fn, initialValue) {\n      var ranges = indexSet.__ranges__,\n          cursor = 0,\n          next   = ranges[cursor],\n          isValueSet = false,\n          value;\n\n      if (arguments.length > 2) {\n        value = initalValue;\n        isValueSet = true;\n      }\n\n      while (next !== END_OF_SET) {\n        if (next > 0) {\n          for (var i = cursor; i < next; i++) {\n            if (isValueSet) {\n              value = fn(value, i, indexSet);\n            } else {\n              value = i;\n              isValueSet = true;\n            }\n          }\n        }\n        cursor = Math.abs(next);\n        next = ranges[cursor];\n      }\n\n      if (!isValueSet) {\n        throw new TypeError(\'Reduce of empty IndexSet with no initial value\');\n      }\n\n      return value;\n    }\n\n    function some(indexSet, fn, scope) {\n      var ranges = indexSet.__ranges__,\n          cursor = 0,\n          next   = ranges[cursor];\n\n      if (typeof scope === \"undefined\") {\n        scope = null;\n      }\n\n      while (next !== END_OF_SET) {\n        if (next > 0) {\n          for (var i = cursor; i < next; i++) {\n            if (fn.call(scope, i, indexSet)) {\n              return true;\n            }\n          }\n        }\n        cursor = Math.abs(next);\n        next = ranges[cursor];\n      }\n      return false;\n    }\n\n    function every(indexSet, fn, scope) {\n      var ranges = indexSet.__ranges__,\n          cursor = 0,\n          next   = ranges[cursor];\n\n      if (typeof scope === \"undefined\") {\n        scope = null;\n      }\n\n      while (next !== END_OF_SET) {\n        if (next > 0) {\n          for (var i = cursor; i < next; i++) {\n            if (!fn.call(scope, i, indexSet)) {\n              return false;\n            }\n          }\n        }\n        cursor = Math.abs(next);\n        next = ranges[cursor];\n      }\n      return true;\n    }\n\n    function forEachRange(indexSet, fn, scope) {\n      var ranges = indexSet.__ranges__,\n          cursor = 0,\n          next   = ranges[cursor];\n\n      if (typeof scope === \"undefined\") {\n        scope = null;\n      }\n\n      while (next !== END_OF_SET) {\n        if (next > 0) {\n          fn.call(scope, cursor, next - cursor, indexSet);\n        }\n        cursor = Math.abs(next);\n        next = ranges[cursor];\n      }\n    }\n\n    function someRange(indexSet, fn, scope) {\n      var ranges = indexSet.__ranges__,\n          cursor = 0,\n          next   = ranges[cursor];\n\n      if (typeof scope === \"undefined\") {\n        scope = null;\n      }\n\n      while (next !== END_OF_SET) {\n        if (next > 0) {\n          if (fn.call(scope, cursor, next - cursor, indexSet)) {\n            return true;\n          }\n        }\n        cursor = Math.abs(next);\n        next = ranges[cursor];\n      }\n      return false;\n    }\n\n    function everyRange(indexSet, fn, scope) {\n      var ranges = indexSet.__ranges__,\n          cursor = 0,\n          next   = ranges[cursor];\n\n      if (typeof scope === \"undefined\") {\n        scope = null;\n      }\n\n      while (next !== END_OF_SET) {\n        if (next > 0) {\n          if (!fn.call(scope, cursor, next - cursor, indexSet)) {\n            return false;\n          }\n        }\n        cursor = Math.abs(next);\n        next = ranges[cursor];\n      }\n      return true;\n    }\n\n    __exports__.forEach = forEach;\n    __exports__.map = map;\n    __exports__.reduce = reduce;\n    __exports__.some = some;\n    __exports__.every = every;\n    __exports__.forEachRange = forEachRange;\n    __exports__.someRange = someRange;\n    __exports__.everyRange = everyRange;\n  });//# sourceURL=index-set/enumeration.js");
eval("define(\"index-set/hint\", \n  [\"index-set/env\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    var ENV = __dependency1__[\"default\"];\n\n    function addHintFor(indexSet, rangeStart, rangeLength) {\n      var ranges = indexSet.__ranges__,\n          skip   = ENV.HINT_SIZE,\n          next   = Math.abs(ranges[rangeStart]),\n          hintLocation = rangeStart - (rangeStart % skip) + skip,\n          limit  = rangeStart + rangeLength;\n\n      while (hintLocation < limit) {\n        // Ensure we are in the current range\n        while (next !== ENV.END_OF_SET && next <= hintLocation) {\n          rangeStart = next;\n          next = Math.abs(ranges[rangeStart]);\n        }\n\n        // We\'re past the end of the set\n        if (next === ENV.END_OF_SET) {\n          delete ranges[hintLocation];\n\n        // Don\'t mark a hint if it\'s a range boundary\n        } else if (hintLocation !== rangeStart &&\n                   rangeStart !== ENV.END_OF_SET) {\n          ranges[hintLocation] = rangeStart;\n        }\n\n        hintLocation += skip;\n      }\n    }\n\n    __exports__[\"default\"] = addHintFor;\n  });//# sourceURL=index-set/hint.js");
eval("define(\"index-set/observing\", \n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    var toString = Object.prototype.toString,\n        slice = Array.prototype.slice,\n        META_KEY = \'__js-index_set__\' + (new Date().getTime()),\n        T_FUNCTION = \'[object Function]\',\n        T_STRING   = \'[object String]\',\n        T_NUMBER   = \'[object Number]\',\n        T_BOOLEAN  = \'[object Boolean]\',\n        T_OBJECT   = \'[object Object]\',\n        uuid = 0,\n        st = {}; // string cache\n\n    function meta(o, create) {\n      var info = o && o[META_KEY];\n      if (create && info == null) {\n        info = o[META_KEY] = {};\n      }\n      return info;\n    }\n\n    function destroy(o) {\n      if (o != null) {\n        delete o[META_KEY];\n      }\n    }\n\n    function metaPath(o, path, value) {\n      var i = 0, len = path ? path.length : 0,\n          m;\n\n      if (arguments.length === 3) {\n        m = meta(o, true);\n        for (; i < len - 1; i++) {\n          o = m[path[i]] || {};\n          m[path[i]] = o;\n          m = o;\n        }\n        m[path[len - 1]] = value;\n        m = value;\n      } else {\n        m = meta(o);\n        for (; i < len; i++) {\n          m = m ? m[path[i]] : undefined;\n        }\n      }\n      return m;\n    }\n\n    function guidFor(o) {\n      if (o === null) return \'(null)\';\n      if (o === void(0)) return \'(undefined)\';\n\n      var cache, result, m,\n          type = toString.call(o);\n\n      switch(type) {\n      case T_NUMBER:\n        result = \'nu\' + o;\n        break;\n      case T_STRING:\n        result = st[o];\n        if (!result) result = st[o] = \'st\' + (uuid++);\n        break;\n      case T_BOOLEAN:\n        result = o ? \'(true)\' : \'(false)\';\n        break;\n      default:\n        if (o === Object) return \'{}\';\n        if (o === Array) return \'[]\';\n        m = meta(o, true);\n        result = m.guid;\n        if (!result) result = m.guid = \'cr\' + (uuid++);\n      }\n      return result;\n    }\n\n    function set(hostObject, key, value) {\n      var currentValue = hostObject[key];\n\n      // Only set values if they have changed\n      if (currentValue !== value) {\n        trigger(hostObject, key + \':before\', value);\n        hostObject[key] = value;\n        trigger(hostObject, key + \':change\', value);\n      }\n    }\n\n    function on(hostObject, event, target, method) {\n      if (toString.call(method) !== T_FUNCTION) {\n        throw new TypeError(method + \' is not callable.\');\n      }\n\n      metaPath(hostObject, [\'events\', event, guidFor(target), guidFor(method)], {\n        method: method,\n        target:  target\n      });\n    }\n\n    function off(hostObject, event, target, method) {\n      var m = metaPath(hostObject, [\'events\', event, guidFor(target)]);\n\n      if (m) {\n        delete m[guidFor(method)];\n      }\n    }\n\n    function trigger(hostObject, event, value) {\n      var targetSets = metaPath(hostObject, [\'events\', event]),\n          args = slice.call(arguments),\n          subscription,\n          set,\n          subscriptions, k;\n\n      if (targetSets) {\n        for (set in targetSets) {\n          subscriptions = targetSets[set];\n          for (k in subscriptions) {\n            subscription = subscriptions[k];\n\n            subscription.method.apply(subscription.target, args);\n          }\n        }\n      }\n    }\n\n    __exports__.set = set;\n    __exports__.on = on;\n    __exports__.off = off;\n    __exports__.trigger = trigger;\n    __exports__.destroy = destroy;\n  });//# sourceURL=index-set/observing.js");
eval("define(\"index-set/removal\", \n  [\"index-set/range_start\",\"index-set/enumeration\",\"index-set/env\",\"index-set/hint\",\"index-set/observing\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {\n    \"use strict\";\n    var rangeStartForIndex = __dependency1__[\"default\"];\n    var forEachRange = __dependency2__.forEachRange;\n    var ENV = __dependency3__[\"default\"];\n    var addHintFor = __dependency4__[\"default\"];\n    var set = __dependency5__.set;\n\n    var END_OF_SET = ENV.END_OF_SET;\n\n    /**\n      @private\n      @method removeIndex\n      @param  indexSet {IndexSet} The target index set to remove the index from.\n      @param  index    {Number}   The index to remove from the target index set.\n     */\n    function removeIndex(indexSet, index) {\n      removeIndexesInRange(indexSet, index, 1);\n    }\n\n    function removeRange(rangeStart, rangeLength) {\n      removeIndexesInRange(this, rangeStart, rangeLength);\n    }\n\n    /**\n      @private\n      @method removeIndexes\n      @param  indexSet {IndexSet} The target index set to remove the indexes from.\n      @param  indexes  {IndexSet} The indexes to remove from the target index set.\n     */\n    function removeIndexes(indexSet, indexes) {\n      forEachRange(indexes, removeRange, indexSet);\n    }\n\n    function removeIndexesInRange(indexSet, rangeStart, rangeLength) {\n      var lastIndex = indexSet.lastIndex + 1,\n          ranges    = indexSet.__ranges__,\n          rangeEnd  = rangeStart + rangeLength,\n          cursor,\n          next,\n          delta = 0;\n\n      // The range being removed isn\'t in the set\n      if (rangeStart >= lastIndex) {\n        return this;\n      }\n\n      cursor = rangeStartForIndex(indexSet, rangeStart);\n      next   = ranges[cursor];\n\n      // The start of the range to remove is on a range boundary;\n      // iterate back to the previous range\n      if (rangeStart > 0 && cursor === rangeStart && next > 0) {\n        cursor = rangeStartForIndex(indexSet, rangeStart - 1);\n        next   = ranges[cursor];\n      }\n\n      // We found a range in the set\n      if (next > 0) {\n        ranges[cursor] = rangeStart;\n\n        // The range extends beyond the range being added\n        if (next > rangeEnd) {\n          // Mark the start and end of the set.\n          ranges[rangeStart] = rangeEnd;\n          ranges[rangeEnd]   = next;\n\n        // The end of the hole has already been taken care of\n        } else {\n          ranges[rangeStart] = next;\n        }\n\n      // The range we found is a hole\n      } else {\n       // Normalize variables so we can split ranges apart\n        rangeStart = cursor;\n        next       = Math.abs(next);\n        if (next > rangeEnd) {\n          rangeEnd = next;\n        }\n      }\n\n      // Walk ranges until we end up past the end of the\n      // range being removed\n      var value;\n      cursor = rangeStart;\n      while (cursor < rangeEnd) {\n        // Find the next boundary location.\n        value = ranges[cursor];\n\n        // We reached the end of the set;\n        // Mark the end of the range as the end of the set\n        if (value === END_OF_SET) {\n          ranges[rangeEnd] = END_OF_SET;\n          next = rangeEnd;\n\n        } else {\n          next = Math.abs(value);\n\n          // The start of the next range is after\n          // the end of the range being removed\n          if (next > rangeEnd) {\n            ranges[rangeEnd] = value;\n            next = rangeEnd;\n          }\n\n          // The range has been removed;\n          // Add to the delta if we have any indexes removed\n          if (value > 0) {\n            delta += next - cursor;\n          }\n        }\n\n        // Delete the range boundary.\n        delete ranges[cursor];\n\n        // Iterate to the next range boundary in the set\n        cursor = next;\n      }\n\n      // The cursor should be the end of range being added.\n      // If the range following the cursor is a hole,\n      // clean up the redundant boundary\n      cursor = ranges[rangeEnd];\n      if (cursor < 0) {\n        delete ranges[rangeEnd];\n        rangeEnd = Math.abs(cursor);\n      }\n\n      // If the next range is the end of the set,\n      // move the end of the set to be the start of the\n      // range being removed.\n      if (ranges[rangeEnd] === END_OF_SET) {\n        delete ranges[rangeEnd];\n        ranges[rangeStart] = END_OF_SET;\n        set(indexSet, \'lastIndex\', rangeStart - 1);\n\n      // Finally, mark the beginning of the range as a hole\n      } else {\n        ranges[rangeStart] = 0 - rangeEnd;\n      }\n\n      set(indexSet, \'length\', indexSet.length - delta);\n\n      // Compute hint length\n      rangeLength = rangeEnd - rangeStart;\n\n      addHintFor(indexSet, rangeStart, rangeLength);\n\n      // The firstIndex of the set might\'ve changed\n      if (delta !== 0) {\n        cursor = ranges[0];\n\n        // No indexes for there to be a firstIndex\n        if (cursor === END_OF_SET) {\n          set(indexSet, \'firstIndex\', -1);\n        // We have a filled range starting at 0\n        } else if (cursor > 0) {\n          set(indexSet, \'firstIndex\', 0);\n        // Use the pointer to the first filled range\n        } else {\n          set(indexSet, \'firstIndex\', Math.abs(cursor));\n        }\n      }\n    }\n\n    __exports__.removeIndex = removeIndex;\n    __exports__.removeIndexes = removeIndexes;\n    __exports__.removeIndexesInRange = removeIndexesInRange;\n  });//# sourceURL=index-set/removal.js");
eval("define(\"index-set/coding\", \n  [\"index-set/enumeration\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    var forEachRange = __dependency1__.forEachRange;\n\n    function serializer(rangeStart, rangeLength) {\n      if (rangeLength === 1) {\n        this.push(rangeStart);\n      } else {\n        this.push(rangeStart + \"-\" + (rangeStart + rangeLength - 1));\n      }\n    }\n\n    function serialize(indexSet) {\n      var buffer = [];\n      forEachRange(indexSet, serializer, buffer);\n      return buffer.join(\',\');\n    }\n\n    function deserialize(indexSet, string, strict) {\n      // Handle an empty set\n      if (string === \'\') {\n        return indexSet;\n      }\n\n      var ranges = string.split(\',\'),\n          range,\n          rangeStart,\n          rangeEnd;\n\n      for (var i = 0, len = ranges.length; i < len; i++) {\n        range = ranges[i];\n        if (range.indexOf(\'-\') !== -1) {\n          range = range.split(\'-\');\n          rangeStart = parseInt(range[0], 10);\n          rangeEnd   = parseInt(range[1], 10);\n\n          if (isNaN(rangeEnd)) {\n            if (strict) {\n              throw new SyntaxError(\'Expected a complete range, instead got \"\' + ranges[i] + \'\".\');\n            }\n            rangeEnd = rangeStart;\n          }\n\n          if (rangeEnd < rangeStart) {\n            if (strict) {\n              throw new SyntaxError(\'Expected an ascending range, instead got a descending one: \"\' + ranges[i] + \'\".\');\n            }\n\n            var swap = rangeEnd;\n            rangeEnd   = rangeStart;\n            rangeStart = swap;\n          } else if (rangeEnd == rangeStart && strict) {\n            throw new SyntaxError(\'Expected a range, not a no-op range: \"\' + ranges[i] + \'\".\');\n          }\n\n          // Include the rangeEnd\n          rangeEnd += 1;\n\n          indexSet.addIndexesInRange(rangeStart, rangeEnd - rangeStart);\n        } else {\n          rangeStart = parseInt(range, 10);\n          if (!isNaN(rangeStart)) {\n            indexSet.addIndex(rangeStart);\n          } else if (strict) {\n            throw new SyntaxError(\'Expected an index, but got non-number: \"\' + range + \'\".\');\n          }\n        }\n      }\n      return indexSet;\n    }\n\n    __exports__.serialize = serialize;\n    __exports__.deserialize = deserialize;\n  });//# sourceURL=index-set/coding.js");
eval("define(\"index-set/queries\", \n  [\"index-set/range_start\",\"index-set/enumeration\",\"index-set/env\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {\n    \"use strict\";\n    var rangeStartForIndex = __dependency1__[\"default\"];\n    var someRange = __dependency2__.someRange;\n    var everyRange = __dependency2__.everyRange;\n    var ENV = __dependency3__[\"default\"];\n\n    var END_OF_SET = ENV.END_OF_SET;\n\n    function containsIndex(indexSet, index) {\n      return containsIndexesInRange(indexSet, index, 1);\n    }\n\n    function containsRange(rangeStart, rangeLength) {\n      return containsIndexesInRange(this, rangeStart, rangeLength);\n    }\n\n    function containsIndexes(indexSet, indexes) {\n      // Fast path if the objects are the same\n      if (indexSet === indexes) {\n        return true;\n      }\n\n      return everyRange(indexes, containsRange, indexSet);\n    }\n\n    function containsIndexesInRange(indexSet, rangeStart, rangeLength) {\n      var ranges = indexSet.__ranges__,\n          cursor,\n          next;\n\n      cursor = rangeStartForIndex(indexSet, rangeStart);\n      if (isFinite(cursor)) {\n        next = ranges[cursor];\n\n        return next > 0 &&\n               cursor <= rangeStart &&\n               next >= rangeStart + rangeLength;\n      } else {\n        return true;\n      }\n    }\n\n    function intersectsIndex(indexSet, index) {\n      return intersectsIndexesInRange(indexSet, index, 1);\n    }\n\n    function intersectsRange(rangeStart, rangeLength) {\n      return intersectsIndexesInRange(this, rangeStart, rangeLength);\n    }\n\n    function intersectsIndexes(indexSet, indexes) {\n      // Fast path if the objects are the same\n      if (indexSet === indexes) {\n        return true;\n      }\n\n      return someRange(indexes, intersectsRange, indexSet);\n    }\n\n    function intersectsIndexesInRange(indexSet, rangeStart, rangeLength) {\n      var ranges = indexSet.__ranges__,\n          cursor = rangeStartForIndex(indexSet, rangeStart),\n          next   = ranges[cursor],\n          limit  = rangeStart + rangeLength;\n\n      while (cursor < limit) {\n        if (next === END_OF_SET) {\n          return false;\n        }\n        if (next > 0 && next > rangeStart) {\n          return true;\n        }\n        cursor = Math.abs(next);\n        next   = ranges[cursor];\n      }\n      return false;\n    }\n\n    function equals(aIndexSet, bIndexSet) {\n      if (aIndexSet === bIndexSet) {\n        return true;\n      }\n      if (bIndexSet == null ||\n          bIndexSet.lastIndex !== aIndexSet.lastIndex ||\n          bIndexSet.length    !== aIndexSet.length) {\n        return false;\n      }\n\n      var aRanges = aIndexSet.__ranges__,\n          bRanges = bIndexSet.__ranges__,\n          cursor  = 0,\n          next    = aRanges[cursor];\n\n      do {\n        if (bRanges[cursor] !== next) {\n          return false;\n        }\n        cursor = Math.abs(next);\n        next   = aRanges[cursor];\n      } while (cursor !== END_OF_SET);\n      return true;\n    }\n\n\n    __exports__.containsIndex = containsIndex;\n    __exports__.containsIndexes = containsIndexes;\n    __exports__.containsIndexesInRange = containsIndexesInRange;\n    __exports__.intersectsIndex = intersectsIndex;\n    __exports__.intersectsIndexes = intersectsIndexes;\n    __exports__.intersectsIndexesInRange = intersectsIndexesInRange;\n    __exports__.equals = equals;\n  });//# sourceURL=index-set/queries.js");
eval("define(\"index-set/indexes\", \n  [\"index-set/env\",\"index-set/range_start\",\"exports\"],\n  function(__dependency1__, __dependency2__, __exports__) {\n    \"use strict\";\n    var ENV = __dependency1__[\"default\"];\n    var rangeStartForIndex = __dependency2__[\"default\"];\n\n    var END_OF_SET = ENV.END_OF_SET;\n\n    function indexLessThanIndex(indexSet, index) {\n      return indexLessThanOrEqualToIndex(indexSet, index - 1);\n    }\n\n    function indexLessThanOrEqualToIndex(indexSet, index) {\n      // No indexes before 0\n      if (index <= 0) {\n        return -1;\n      }\n\n      var ranges     = indexSet.__ranges__,\n          lastIndex  = indexSet.lastIndex + 1,\n          cursor     = rangeStartForIndex(indexSet, index);\n\n      while (cursor === lastIndex || ranges[cursor] < 0) {\n        // There are no indexes before this index\n        if (cursor === END_OF_SET) {\n          return -1;\n        }\n        index  = cursor - 1;\n        cursor = rangeStartForIndex(indexSet, index);\n\n        if (cursor === -1) {\n          return cursor;\n        }\n      }\n\n      return index;\n    }\n\n    function indexGreaterThanIndex(indexSet, index) {\n      return indexGreaterThanOrEqualToIndex(indexSet, index + 1);\n    }\n\n    function indexGreaterThanOrEqualToIndex(indexSet, index) {\n      var ranges     = indexSet.__ranges__,\n          lastIndex  = indexSet.lastIndex + 1,\n          cursor,\n          next;\n\n      // No indexes after the last index\n      if (index >= lastIndex) {\n        return -1;\n      }\n\n      cursor = rangeStartForIndex(indexSet, index);\n      next   = ranges[cursor];\n\n      // Until we find the next filled range\n      while (next < 0) {\n        // No items after the end of this set\n        if (next === END_OF_SET) {\n          return -1;\n        }\n\n        index = cursor = Math.abs(next);\n        next  = ranges[cursor];\n      }\n\n      return index;\n    }\n\n    __exports__.indexLessThanIndex = indexLessThanIndex;\n    __exports__.indexLessThanOrEqualToIndex = indexLessThanOrEqualToIndex;\n    __exports__.indexGreaterThanIndex = indexGreaterThanIndex;\n    __exports__.indexGreaterThanOrEqualToIndex = indexGreaterThanOrEqualToIndex;\n  });//# sourceURL=index-set/indexes.js");
eval("define(\"loader\", \n  [],\n  function() {\n    \"use strict\";\n    var define, require;\n\n    (function () {\n      var registry = {}, seen = {};\n\n      define = function (name, deps, callback) {\n        registry[name] = { deps: deps, callback: callback };\n      };\n\n      require = function (name) {\n        if (seen[name]) { return seen[name]; }\n        seen[name] = {};\n\n        var mod = registry[name],\n            deps = mod.deps,\n            callback = mod.callback,\n            reified = [],\n            exports;\n\n        for (var i=0, l=deps.length; i<l; i++) {\n          if (deps[i] === \'exports\') {\n            reified.push(exports = {});\n          } else {\n            reified.push(require(deps[i]));\n          }\n        }\n\n        var value = callback.apply(this, reified);\n        return seen[name] = exports || value;\n      };\n    })();\n  });//# sourceURL=loader.js");
eval("define(\"tests/index-set/add\", \n  [],\n  function() {\n    \"use strict\";\n    var set;\n\n    module(\"IndexSet#addIndexesInRange\", {\n      setup: function () {\n        set = new IndexSet();\n      }\n    });\n\n    function K(value) { return value; }\n\n    // ..........................................................\n    // BASIC ADDS\n    //\n\n    test(\"adding a range to end of set\", function () {\n      set.addIndexesInRange(1000, 5);\n      equal(set.length, 5);\n      equal(set.lastIndex, 1004);\n      deepEqual(set.map(K), [1000, 1001, 1002, 1003, 1004]);\n    });\n\n    test(\"addding a range into middle of empty range\", function () {\n      set.addIndexesInRange(100, 2);\n      equal(set.firstIndex, 100);\n\n      set.addIndexesInRange(10, 1);\n      equal(set.length, 3, \'the length should be increased by one\');\n      equal(set.lastIndex, 101, \"the lastIndex shouldn\'t have changed\");\n      deepEqual(set.map(K), [10, 100, 101]);\n    });\n\n    test(\"add range overlapping front edge of range\", function () {\n      set.addIndexesInRange(100, 2);\n      equal(set.firstIndex, 100);\n\n      set.addIndexesInRange(99, 2);\n      equal(set.length, 3);\n      equal(set.lastIndex, 101);\n      deepEqual(set.map(K), [99, 100, 101]);\n    });\n\n    test(\"add range overlapping last edge of range\", function () {\n      set.addIndexesInRange(100, 2);\n      set.addIndexesInRange(200, 2);\n      deepEqual(set.map(K), [100, 101, 200, 201]);\n\n      set.addIndexesInRange(101, 2);\n      equal(set.length, 5);\n      equal(set.lastIndex, 201);\n      deepEqual(set.map(K), [100, 101, 102, 200, 201], \'should include 101..102\');\n    });\n\n    test(\"add range overlapping two ranges, merging into one\", function () {\n      set.addIndexesInRange(100, 2);\n      set.addIndexesInRange(110, 2);\n      deepEqual(set.map(K), [100, 101, 110, 111]);\n\n      // now add overlapping range\n      set.addIndexesInRange(101, 10);\n      equal(set.length, 12);\n      equal(set.lastIndex, 111);\n      deepEqual(set.map(K), [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111], \'should include one range 100..111\');\n    });\n\n    test(\"add range overlapping three ranges, merging into one\", function () {\n      set.addIndexesInRange(100, 2)\n         .addIndexesInRange(105, 2)\n         .addIndexesInRange(110, 2);\n      deepEqual(set.map(K), [100, 101, 105, 106, 110, 111]);\n\n      // now add overlapping range\n      set.addIndexesInRange(101, 10);\n      equal(set.length, 12);\n      equal(set.lastIndex, 111);\n      deepEqual(set.map(K), [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111], \'should include one range 100..111\');\n    });\n\n    test(\"add range partially overlapping one range and replacing another range, merging into one\", function () {\n      set.addIndexesInRange(100, 2).addIndexesInRange(105, 2);\n      deepEqual(set.map(K), [100, 101, 105, 106], \'should have two sets\');\n\n      // now add overlapping range\n      set.addIndexesInRange(101, 10);\n      equal(set.length, 11, \'new set.length\');\n\n      equal(set.lastIndex, 110);\n      deepEqual(set.map(K), [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110], \'should include one range 100..110\');\n    });\n\n    test(\"add range overlapping last index\", function () {\n      set.addIndexesInRange(100, 2);\n      equal(set.firstIndex, 100, \'precond - first index is 100\');\n\n      // now add second range\n      set.addIndexesInRange(101, 2);\n      equal(set.length, 3, \'should have extra length\');\n      equal(set.lastIndex, 102);\n      deepEqual(set.map(K), [100, 101, 102]);\n    });\n\n    test(\"add range matching existing range\", function () {\n      set.addIndexesInRange(100, 5);\n      equal(set.firstIndex, 100, \'precond - first index is 100\');\n\n      // now add second range\n      set.addIndexesInRange(100,5);\n      equal(set.length, 5, \'should not change\');\n      equal(set.lastIndex, 104);\n      deepEqual(set.map(K), [100, 101, 102, 103, 104]);\n    });\n\n    // ..........................................................\n    // Other behaviors\n    //\n\n    test(\"appending a range to end should merge into last range\", function () {\n      set = new IndexSet();\n      set.addIndex(2);\n      set.addIndex(3);\n      equal(set.lastIndex, 3);\n      equal(set.length, 2);\n\n      set = new IndexSet();\n      set.addIndexesInRange(2000, 1000);\n      set.addIndexesInRange(3000, 1000);\n      equal(set.lastIndex, 3999);\n      equal(set.length, 2000);\n    });\n\n    test(\"appending range to start of empty set should create a single range\", function () {\n      set = new IndexSet();\n      set.addIndexesInRange(0, 2);\n      equal(set.length, 2);\n      equal(set.lastIndex, 1);\n\n      set = new IndexSet();\n      set.addIndexesInRange(0, 2000);\n      equal(set.length, 2000);\n      equal(set.lastIndex, 1999);\n    });\n\n    // ..........................................................\n    // NORMALIZED PARAMETER CASES\n    //\n\n    test(\"add with no params should do nothing\", function () {\n      set.add();\n      deepEqual(set.map(K), []);\n    });\n\n    test(\"add with single number should add index only\", function () {\n      set.addIndex(2);\n      deepEqual(set.map(K), [2]);\n    });\n\n    test(\"add with index set should add indexes in set\", function() {\n      set.addIndexes(new IndexSet().add(2, 2).add(10, 2));\n      deepEqual(set.map(K), [2,3,10,11]);\n    });\n\n    // ..........................................................\n    // SPECIAL CASES\n    //\n    // demonstrate fixes for specific bugs here.\n\n    test(\"adding ranges within the set shouldn\'t change the overall size of the set\", function () {\n      set = new IndexSet();\n      set.addIndexesInRange(1, 4);\n      equal(set.length, 4);\n\n      set.addIndexesInRange(1, 3);\n      equal(set.length, 4);\n\n      set.addIndexesInRange(1, 2);\n      equal(set.length, 4);\n    });\n  });//# sourceURL=tests/index-set/add.js");
eval("define(\"tests/index-set/coding\", \n  [],\n  function() {\n    \"use strict\";\n    var set;\n\n    module(\"IndexSet#serialize\", {\n      setup: function () {\n        set = new IndexSet();\n      }\n    });\n\n    test(\"an empty set\", function () {\n      equal(set.serialize(), \'\');\n    });\n\n    test(\"single indexes are listed as comma separated values\", function () {\n      set.add(1).add(5).add(7);\n      equal(set.serialize(), \'1,5,7\');\n    });\n\n    test(\"index ranges are listed as values separated by `-`\", function () {\n      set.add(1, 5);\n      equal(set.serialize(), \'1-5\');\n    });\n\n    test(\"index ranges and single values are displayed correctly together\", function () {\n      set.add(1).add(3, 7).add(22, 2).add(30);\n      equal(set.serialize(), \'1,3-9,22-23,30\');\n    });\n\n\n    module(\"IndexSet#deserialize\");\n\n    function K(value) { return value; }\n\n    test(\"deserializing an empty set\", function () {\n      deepEqual(IndexSet.deserialize(\"\").map(K), []);\n    });\n\n    test(\"deserializing a single index\", function () {\n      deepEqual(IndexSet.deserialize(\"1\").map(K), [1]);\n    });\n\n    test(\"deserializing multiple indexes\", function () {\n      deepEqual(IndexSet.deserialize(\"1,5,7\").map(K), [1, 5, 7]);\n    });\n\n    test(\"deserializing a single range\", function () {\n      deepEqual(IndexSet.deserialize(\"1-5\").map(K), [1, 2, 3, 4, 5]);\n    });\n\n    test(\"deserializing multiple ranges\", function () {\n      deepEqual(IndexSet.deserialize(\"3-9,22-23\").map(K), [3, 4, 5, 6, 7, 8, 9, 22, 23]);\n    });\n\n    test(\"deserializing mixed ranges and indexes\", function () {\n      deepEqual(IndexSet.deserialize(\"1,3-9,22-23,30\").map(K), [1, 3, 4, 5, 6, 7, 8, 9, 22, 23, 30]);\n    });\n\n    test(\"deserializing out of order ranges and indexes\", function () {\n      deepEqual(IndexSet.deserialize(\"30,3-4,22,7,5,49-52\").map(K), [3, 4, 5, 7, 22, 30, 49, 50, 51, 52]);\n    });\n\n    test(\"deserializing lists with trailing commas\", function () {\n      deepEqual(IndexSet.deserialize(\"30,3-4,\").map(K), [3, 4, 30]);\n    });\n\n    test(\"deserializing incomplete ranges\", function () {\n      deepEqual(IndexSet.deserialize(\"30,3-\").map(K), [3, 30]);\n    });\n\n    test(\"deserializing inverted ranges\", function () {\n      deepEqual(IndexSet.deserialize(\"30,3-1\").map(K), [1, 2, 3, 30]);\n    });\n\n    test(\"deserializing zero-length ranges\", function () {\n      deepEqual(IndexSet.deserialize(\"30,3-3\").map(K), [3, 30]);\n    });\n\n\n    module(\"IndexSet#deserialize (strict)\");\n\n    test(\"deserializing lists with trailing commas throws an error\", function () {\n      throws(function () {\n        IndexSet.deserialize(\"30,3-4,\", true);\n      }, SyntaxError);\n    });\n\n    test(\"deserializing incomplete ranges throws an error\", function () {\n      throws(function () {\n        IndexSet.deserialize(\"30,3-\", true);\n      }, SyntaxError);\n    });\n\n    test(\"deserializing inverted ranges throws an error\", function () {\n      throws(function () {\n        IndexSet.deserialize(\"30,3-1\", true);\n      }, SyntaxError);\n    });\n\n    test(\"deserializing zero-length ranges throws an error\", function () {\n      throws(function () {\n        IndexSet.deserialize(\"30,3-3\", true);\n      }, SyntaxError);\n    });\n  });//# sourceURL=tests/index-set/coding.js");
eval("define(\"tests/index-set/contains\", \n  [],\n  function() {\n    \"use strict\";\n    var set;\n\n    // ..........................................................\n    // SINGLE INDEX\n    //\n\n    module(\"IndexSet#containsIndex\", {\n      setup: function () {\n        set = new IndexSet();\n        set.addIndexesInRange(1000, 10)\n           .addIndexesInRange(2000, 1);\n      }\n    });\n\n    test(\"handle index in set\", function () {\n      equal(set.containsIndex(1001), true);\n      equal(set.containsIndex(1009), true);\n      equal(set.containsIndex(2000), true);\n    });\n\n    test(\"handle index not in set\", function () {\n      equal(set.containsIndex(0), false);\n      equal(set.containsIndex(10), false);\n      equal(set.containsIndex(1100), false);\n    });\n\n    test(\"handle index past end of set\", function () {\n      equal(set.containsIndex(3000), false);\n    });\n\n    // ..........................................................\n    // RANGE\n    //\n\n    module(\"IndexSet#containsIndexesInRange\", {\n      setup: function () {\n        set = new IndexSet();\n        set.addIndexesInRange(1000, 10)\n           .addIndexesInRange(2000,1);\n      }\n    });\n\n    test(\"handle range inside set\", function () {\n      equal(set.containsIndexesInRange(1001, 4), true);\n    });\n\n    test(\"handle range outside of set\", function () {\n      equal(set.containsIndexesInRange(100, 4), false);\n    });\n\n    test(\"handle range partially inside set\", function () {\n      equal(set.containsIndexesInRange(998, 4), false);\n    });\n\n    // ..........................................................\n    // INDEX SET\n    //\n\n    module(\"IndexSet#containsIndexes\", {\n      setup: function () {\n        set = new IndexSet();\n        set.addIndexesInRange(1000, 10)\n           .addIndexesInRange(2000,1);\n      }\n    });\n\n    test(\"handle set inside IndexSet\", function () {\n      var test = new IndexSet();\n      test.addIndexesInRange(1001, 4)\n          .addIndexesInRange(1005, 2);\n      equal(set.containsIndexes(test), true);\n    });\n\n    test(\"handle range outside of IndexSet\", function () {\n      var test = new IndexSet();\n      test.addIndexesInRange(100, 4)\n          .addIndexesInRange(105, 2);\n      equal(set.containsIndexes(test), false);\n    });\n\n    test(\"handle range partially inside IndexSet\", function () {\n      var test = new IndexSet();\n      test.addIndexesInRange(1001, 4)\n          .addIndexesInRange(100, 2);\n      equal(set.containsIndexes(test), false);\n    });\n\n    test(\"handle self\", function () {\n      equal(set.containsIndexes(set), true);\n    });\n  });//# sourceURL=tests/index-set/contains.js");
eval("define(\"tests/index-set/copying\", \n  [],\n  function() {\n    \"use strict\";\n    var set;\n\n    module(\"IndexSet#copy\", {\n      setup: function () {\n        set = new IndexSet();\n      }\n    });\n\n    test(\"copy should return new object with same key properties\", function () {\n      set.add(100, 100)\n         .add(200, 100);\n\n      var copyCat = set.copy();\n      ok(copyCat !== set,     \'the clone should not === the original set\');\n      ok(set.equals(copyCat), \'the clone and the original set should have the same content\');\n\n      equal(copyCat.length,     set.length,     \'the clone should have same length\');\n      equal(copyCat.firstIndex, set.firstIndex, \'the clone should have same firstIndex\');\n      equal(copyCat.lastIndex,  set.lastIndex,  \'the clone should have same lastIndex\');\n    });\n  });//# sourceURL=tests/index-set/copying.js");
eval("define(\"tests/index-set/enumeration\", \n  [],\n  function() {\n    \"use strict\";\n    var set;\n\n    module(\"IndexSet#forEach\", {\n      setup: function () {\n        set = new IndexSet(5).add(200, 5);\n      }\n    });\n\n    test(\"iterates through each index in the set\", function () {\n      var indices = [5, 200, 201, 202, 203, 204, 205],\n          i = 0;\n      set.forEach(function (index) {\n        equal(index, indices[i++]);\n      });\n    });\n\n    test(\"the scope of the passed function can be changed\", function () {\n      set.forEach(function () {\n        equal(set, this);\n      }, set);\n    });\n\n    test(\"the iterator gets passed the index and the indexSet\", function () {\n      set.forEach(function (index, indexSet) {\n        equal(indexSet, set);\n      });\n    });\n\n    module(\"Index#forEachRange\", {\n      setup: function () {\n        set = new IndexSet(5).add(200, 100);\n      }\n    });\n\n    test(\"iterates through each range in the set\", function () {\n      var ranges = [{ start:   5, length:   1 },\n                    { start: 200, length: 100 }],\n          i = 0;\n      set.forEachRange(function (start, length) {\n        var range = ranges[i++];\n        equal(start, range.start);\n        equal(length, range.length);\n      });\n    });\n\n    test(\"the scope of the passed function can be changed\", function () {\n      set.forEachRange(function () {\n        equal(set, this);\n      }, set);\n    });\n\n    test(\"the iterator gets passed the range and the indexSet\", function () {\n      set.forEachRange(function (start, length, indexSet) {\n        equal(indexSet, set);\n      });\n    });\n  });//# sourceURL=tests/index-set/enumeration.js");
eval("define(\"tests/index-set/first-index\", \n  [],\n  function() {\n    \"use strict\";\n    module(\"IndexSet#firstIndex\");\n\n    test(\"newly created index\", function() {\n      var set = new IndexSet();\n      equal(set.firstIndex, -1);\n    });\n\n    test(\"after adding one range\", function() {\n      var set = new IndexSet();\n      set.addIndexesInRange(4, 2);\n      equal(set.firstIndex, 4);\n    });\n\n    test(\"after adding range then removing part of range\", function() {\n      var set = new IndexSet();\n      set.addIndexesInRange(4, 4)\n         .removeIndexesInRange(2, 4);\n      equal(set.firstIndex, 6);\n    });\n\n    test(\"after adding range several disjoint ranges\", function() {\n      var set = new IndexSet();\n      set.addIndex(6000)\n         .addIndexesInRange(4, 4);\n      equal(set.firstIndex, 4);\n    });\n\n    test(\"after removing disjoint range\", function() {\n      var set = new IndexSet();\n      set.addIndexesInRange(4, 2)\n         .addIndex(6000)\n         .removeIndexesInRange(2, 10);\n      equal(set.firstIndex, 6000);\n    });\n\n    test(\"after removing all ranges\", function() {\n      var set = new IndexSet();\n      set.addIndexesInRange(4, 2)\n         .addIndex(6000)\n         .removeIndexesInRange(3, 6200);\n      equal(set.firstIndex, -1);\n    });\n\n\n    test(\"newly created index, clearing and then adding\", function() {\n      var set = new IndexSet();\n      set.addIndexesInRange(4, 2);\n      equal(set.firstIndex, 4);\n\n    	set.removeAllIndexes();\n      equal(set.firstIndex, -1);\n\n    	set.addIndexesInRange(7, 3);\n      equal(set.firstIndex, 7);\n    });\n  });//# sourceURL=tests/index-set/first-index.js");
eval("define(\"tests/index-set/index-after\", \n  [],\n  function() {\n    \"use strict\";\n    var set;\n\n    module(\"IndexSet#indexGreaterThanIndex\", {\n      setup: function () {\n        set = new IndexSet(5).add(10, 5).add(100);\n      }\n    });\n\n    test(\"no earlier index in set\", function () {\n      equal(set.indexGreaterThanIndex(3), 5);\n    });\n\n    test(\"with index after end of set\", function () {\n      equal(set.indexGreaterThanIndex(1000), -1);\n    });\n\n    test(\"inside of multi-index range\", function () {\n      equal(set.indexGreaterThanIndex(12), 13);\n    });\n\n    test(\"end of multi-index range\", function () {\n      equal(set.indexGreaterThanIndex(14), 100);\n    });\n\n    test(\"single index range\", function () {\n      equal(set.indexGreaterThanIndex(5), 10);\n    });\n\n\n    module(\"IndexSet#indexGreaterThanOrEqualToIndex\", {\n      setup: function () {\n        set = new IndexSet(5).add(10, 5).add(100);\n      }\n    });\n\n    test(\"no earlier index in set\", function () {\n      equal(set.indexGreaterThanOrEqualToIndex(3), 5);\n    });\n\n    test(\"with index after end of set\", function () {\n      equal(set.indexGreaterThanOrEqualToIndex(1000), -1);\n    });\n\n    test(\"inside of multi-index range\", function () {\n      equal(set.indexGreaterThanOrEqualToIndex(12), 12);\n    });\n\n    test(\"end of multi-index range\", function () {\n      equal(set.indexGreaterThanOrEqualToIndex(14), 14);\n    });\n\n    test(\"single index range\", function () {\n      equal(set.indexGreaterThanOrEqualToIndex(5), 5);\n    });\n  });//# sourceURL=tests/index-set/index-after.js");
eval("define(\"tests/index-set/index-before\", \n  [],\n  function() {\n    \"use strict\";\n    var set;\n\n    module(\"IndexSet#indexLessThanIndex\", {\n      setup: function () {\n        set = new IndexSet(5).add(10, 5).add(100);\n      }\n    });\n\n    test(\"no earlier index in set\", function (){\n      equal(set.indexLessThanIndex(4), -1);\n    });\n\n    test(\"with index after end of set\", function () {\n      equal(set.indexLessThanIndex(1000), 100);\n    });\n\n    test(\"inside of multi-index range\", function () {\n      equal(set.indexLessThanIndex(12), 11);\n    });\n\n    test(\"beginning of multi-index range\", function () {\n      equal(set.indexLessThanIndex(10), 5);\n    });\n\n    test(\"single index range\", function () {\n      equal(set.indexLessThanIndex(100), 14);\n    });\n\n\n    module(\"IndexSet#indexLessThanOrEqualToIndex\", {\n      setup: function () {\n        set = new IndexSet(5).add(10, 5).add(100);\n      }\n    });\n\n    test(\"no earlier index in set\", function (){\n      equal(set.indexLessThanOrEqualToIndex(4), -1);\n    });\n\n    test(\"with index after end of set\", function () {\n      equal(set.indexLessThanOrEqualToIndex(1000), 100);\n    });\n\n    test(\"inside of multi-index range\", function () {\n      equal(set.indexLessThanOrEqualToIndex(12), 12);\n    });\n\n    test(\"beginning of multi-index range\", function () {\n      equal(set.indexLessThanOrEqualToIndex(10), 10);\n    });\n\n    test(\"single index range\", function () {\n      equal(set.indexLessThanOrEqualToIndex(100), 100);\n    });\n  });//# sourceURL=tests/index-set/index-before.js");
eval("define(\"tests/index-set/intersects\", \n  [],\n  function() {\n    \"use strict\";\n    /*global module test equal context ok same notest */\n\n    var set;\n\n    // ..........................................................\n    // SINGLE INDEX\n    //\n\n    module(\"IndexSet#intersectsIndex\", {\n      setup: function () {\n        set = new IndexSet();\n        set.addIndexesInRange(1000, 10)\n           .addIndexesInRange(2000, 1);\n      }\n    });\n\n    test(\"handle index in set\", function () {\n      equal(set.intersectsIndex(1001), true);\n      equal(set.intersectsIndex(1009), true);\n      equal(set.intersectsIndex(2000), true);\n    });\n\n    test(\"handle index not in set\", function () {\n      equal(set.intersectsIndex(0),    false);\n      equal(set.intersectsIndex(10),   false);\n      equal(set.intersectsIndex(1100), false);\n    });\n\n    test(\"handle index past end of set\", function () {\n      equal(set.intersectsIndex(3000), false);\n    });\n\n    // ..........................................................\n    // RANGE\n    //\n\n    module(\"IndexSet#intersectsIndexesInRange\", {\n      setup: function () {\n        set = new IndexSet();\n        set.addIndexesInRange(1000, 10)\n           .addIndexesInRange(2000, 1);\n      }\n    });\n\n    test(\"handle range inside set\", function () {\n      equal(set.intersectsIndexesInRange(1001, 4), true);\n    });\n\n    test(\"handle range outside of set\", function () {\n      equal(set.intersectsIndexesInRange(100, 4), false);\n    });\n\n    test(\"handle range partially inside set\", function () {\n      equal(set.intersectsIndexesInRange(998, 4), true);\n    });\n\n    // ..........................................................\n    // INDEX SET\n    //\n\n    module(\"IndexSet#intersectsIndexes\", {\n      setup: function () {\n        set = new IndexSet();\n        set.addIndexesInRange(1000, 10)\n           .addIndexesInRange(2000, 1);\n      }\n    });\n\n    test(\"handle set inside IndexSet\", function () {\n      var test = new IndexSet();\n      test.addIndexesInRange(1001, 4)\n          .addIndexesInRange(1005, 2);\n      equal(set.intersectsIndexes(test), true);\n    });\n\n    test(\"handle range outside of IndexSet\", function () {\n      var test = new IndexSet();\n      test.addIndexesInRange(100, 4)\n          .addIndexesInRange(105, 2);\n      equal(set.intersectsIndexes(test), false);\n    });\n\n    test(\"handle range partially inside IndexSet\", function () {\n      var test = new IndexSet();\n      test.addIndexesInRange(1001, 4)\n          .addIndexesInRange(100, 2);\n      equal(set.intersectsIndexes(test), true);\n    });\n\n    test(\"handle self\", function () {\n      equal(set.intersectsIndexes(set), true);\n    });\n  });//# sourceURL=tests/index-set/intersects.js");
eval("define(\"tests/index-set/last-index\", \n  [],\n  function() {\n    \"use strict\";\n    /*global module test equal */\n\n    var set;\n    module(\"IndexSet#lastIndex\", {\n      setup: function () {\n        set = new IndexSet();\n      }\n    });\n\n    test(\"newly created index\", function() {\n      equal(set.lastIndex, -1, \'there are no indexes in the set\');\n    });\n\n    test(\"after adding one range\", function() {\n      set.addIndexesInRange(4, 2);\n      equal(set.lastIndex, 5);\n    });\n\n    test(\"after adding range then removing part of range\", function() {\n      set.addIndexesInRange(4, 4)\n         .removeIndexesInRange(6, 4);\n      equal(set.lastIndex, 5);\n    });\n\n    test(\"after adding range several disjoint ranges\", function() {\n      set.addIndexesInRange(4, 4)\n         .addIndexesInRange(6000, 1);\n      equal(set.lastIndex, 6000);\n    });\n\n    test(\"after removing disjoint range\", function() {\n      set.addIndexesInRange(4, 2)\n         .addIndex(6000)\n         .removeIndexesInRange(5998, 10);\n      equal(set.lastIndex, 5);\n    });\n\n    test(\"after removing all ranges\", function() {\n      set.addIndexesInRange(4, 2)\n         .addIndex(6000)\n         .removeIndexesInRange(3, 6200);\n      equal(set.lastIndex, -1);\n    });\n  });//# sourceURL=tests/index-set/last-index.js");
eval("define(\"tests/index-set/observing\", \n  [],\n  function() {\n    \"use strict\";\n    var set,\n        event = function (hostObject, _event) {\n          event.args = Array.prototype.slice.call(arguments);\n          event.scope = this;\n          event.called++;\n\n          var key = _event.split(\':\')[0];\n          event.state = {};\n          event.state[key] = hostObject[key];\n        };\n\n    event.reset = function () {\n      delete this.scope;\n      this.called = 0;\n      this.args = [];\n    };\n\n    module(\"IndexSet#on(length:before)\", {\n      setup: function () {\n        set = new IndexSet();\n        event.reset();\n        set.on(\'length:before\', module, event);\n      }\n    });\n\n    test(\"gets called once when the length changes\", function () {\n      set.add(1000, 5);\n      equal(event.called, 1);\n      equal(event.scope, module);\n      equal(event.state.length, 0);\n\n      deepEqual(event.args, [set, \'length:before\', 5]);\n    });\n\n    test(\"doesn\'t get called when the length remains the same\", function () {\n      set.add(2, 5);\n      event.reset();\n      set.add(4);\n\n      equal(event.called, 0);\n    });\n\n\n    module(\"IndexSet#on(length:change)\", {\n      setup: function () {\n        set = new IndexSet();\n        event.reset();\n        set.on(\'length:change\', module, event);\n      }\n    });\n\n    test(\"gets called once when the length changes\", function () {\n      set.add(1000, 5);\n      equal(event.called, 1);\n      equal(event.scope, module);\n      equal(event.state.length, 5);\n\n      deepEqual(event.args, [set, \'length:change\', 5]);\n    });\n\n    test(\"doesn\'t get called when the length remains the same\", function () {\n      set.add(2, 5);\n      event.reset();\n      set.add(4);\n\n      equal(event.called, 0);\n    });\n\n\n    module(\"IndexSet#on(firstIndex:before)\", {\n      setup: function () {\n        set = new IndexSet();\n        event.reset();\n        set.on(\'firstIndex:before\', module, event);\n      }\n    });\n\n    test(\"gets called once when the firstIndex changes\", function () {\n      set.add(1000, 5);\n      equal(event.called, 1);\n      equal(event.scope, module);\n      equal(event.state.firstIndex, -1);\n\n      deepEqual(event.args, [set, \'firstIndex:before\', 1000]);\n    });\n\n    test(\"doesn\'t get called when the length remains the same\", function () {\n      set.add(2, 5);\n      event.reset();\n      set.add(4, 20);\n\n      equal(event.called, 0);\n    });\n\n\n    module(\"IndexSet#on(firstIndex:change)\", {\n      setup: function () {\n        set = new IndexSet();\n        event.reset();\n        set.on(\'firstIndex:change\', module, event);\n      }\n    });\n\n    test(\"gets called once when the firstIndex changes\", function () {\n      set.add(1000, 5);\n      equal(event.called, 1);\n      equal(event.scope, module);\n      equal(event.state.firstIndex, 1000);\n\n      deepEqual(event.args, [set, \'firstIndex:change\', 1000]);\n    });\n\n    test(\"doesn\'t get called when the length remains the same\", function () {\n      set.add(2, 5);\n      event.reset();\n      set.add(4, 20);\n\n      equal(event.called, 0);\n    });\n\n\n    module(\"IndexSet#on(lastIndex:before)\", {\n      setup: function () {\n        set = new IndexSet();\n        event.reset();\n        set.on(\'lastIndex:before\', module, event);\n      }\n    });\n\n    test(\"gets called once when the lastIndex changes\", function () {\n      set.add(1000, 5);\n      equal(event.called, 1);\n      equal(event.scope, module);\n      equal(event.state.lastIndex, -1);\n\n      deepEqual(event.args, [set, \'lastIndex:before\', 1004]);\n    });\n\n    test(\"doesn\'t get called when the length remains the same\", function () {\n      set.add(100, 5);\n      event.reset();\n      set.add(4, 20);\n\n      equal(event.called, 0);\n    });\n\n\n    module(\"IndexSet#on(lastIndex:change)\", {\n      setup: function () {\n        set = new IndexSet();\n        event.reset();\n        set.on(\'lastIndex:change\', module, event);\n      }\n    });\n\n    test(\"gets called once when the lastIndex changes\", function () {\n      set.add(1000, 5);\n      equal(event.called, 1);\n      equal(event.scope, module);\n      equal(event.state.lastIndex, 1004);\n\n      deepEqual(event.args, [set, \'lastIndex:change\', 1004]);\n    });\n\n    test(\"doesn\'t get called when the length remains the same\", function () {\n      set.add(100, 5);\n      event.reset();\n      set.add(4, 20);\n\n      equal(event.called, 0);\n    });\n\n\n    module(\"IndexSet#off\", {\n      setup: function () {\n        set = new IndexSet();\n        event.reset();\n        set.on(\'lastIndex:change\', module, event);\n      }\n    });\n\n    test(\"doesn\'t get called after the event is removed\", function () {\n      set.add(13, 5);\n      event.reset();\n      set.off(\'lastIndex:change\', module, event);\n      set.add(4, 20);\n\n      equal(event.called, 0);\n    });\n  });//# sourceURL=tests/index-set/observing.js");
eval("define(\"tests/index-set/rangeStartForIndex\", \n  [],\n  function() {\n    \"use strict\";\n    var set, start, len;\n    module(\"IndexSet#rangeStartForIndex\", {\n      setup: function () {\n        start = IndexSet.ENV.HINT_SIZE * 2 + 10;\n        len  = Math.floor(IndexSet.ENV.HINT_SIZE * 1.5);\n        set = new IndexSet();\n        set.addIndexesInRange(start, len);\n      }\n    });\n\n    test(\"index is start of range\", function () {\n      equal(set.rangeStartForIndex(start), start);\n      equal(set.rangeStartForIndex(0), 0);\n    });\n\n    test(\"index is middle of range\", function () {\n      equal(set.rangeStartForIndex(start + 20), start);\n      equal(set.rangeStartForIndex(start + IndexSet.ENV.HINT_SIZE), start);\n      equal(set.rangeStartForIndex(20), 0);\n    });\n\n    test(\"index last index\", function () {\n      equal(set.rangeStartForIndex(start + len), start + len);\n    });\n\n    test(\"index past last index\", function () {\n      equal(set.rangeStartForIndex(start + len + 20), start + len);\n    });\n\n    test(\"index sets don\'t infinitely recurse\", function () {\n      var set = new IndexSet();\n\n      set.__ranges__ = new Array(542);\n      set.__ranges__[0]   =   50;\n      set.__ranges__[50]  = -516;\n      set.__ranges__[256] =   25;\n      set.__ranges__[512] =   25;\n      set.__ranges__[516] =  541;\n      set.__ranges__[541] =    0;\n\n      set.firstIndex =   0;\n      set.lastIndex  = 540;\n      set.length     =  75;\n\n      equal(set.rangeStartForIndex(540), 516);\n      equal(set.lastIndex, 540);\n      equal(set.firstIndex, 0);\n      equal(set.length, 75);\n    });\n\n    test(\"creating holes by appending to an existing range should not affect the range start\", function () {\n      var hintSize = IndexSet.ENV.HINT_SIZE,\n          start, set;\n\n      set = new IndexSet();\n\n      set.addIndex(1);\n      set.addIndex(hintSize + 1);\n\n      // Before adding 2,\n      // the internal data structure looks like:\n      // {\n      //   0  : -  1,   // Hole until 1\n      //   1  :    2,   // End of range is 2\n      //   2  : -257,   // Hole until 257\n      //   256:    2,   // Hint points at index 2, which is ok.\n      //   257:  258,   // End of range is 258\n      //   258:    0    // End of index set\n      // }\n      equal(set.rangeStartForIndex(hintSize),\n            set.rangeStartForIndex(hintSize - 1));\n\n      set.addIndex(2);\n\n      // Assuming IndexSet.ENV.HINT_SIZE is 256,\n      // the internal data structure looks like:\n      // {\n      //   0  : -  1,   // Hole until 1\n      //   1  :    3,   // End of range is 3\n      //   3  : -257,   // Hole until 257\n      //   256:    2,   // Hint points at index 2, which is invalid.\n      //   257:  258,   // End of range is 258\n      //   258:    0    // End of index set\n      // }\n      equal(set.rangeStartForIndex(hintSize),\n            set.rangeStartForIndex(hintSize - 1));\n    });\n  });//# sourceURL=tests/index-set/rangeStartForIndex.js");
eval("define(\"tests/index-set/remove\", \n  [],\n  function() {\n    \"use strict\";\n    var set;\n\n    module(\"IndexSet#remove\", {\n      setup: function () {\n        set = new IndexSet();\n      }\n    });\n\n    function K(value) { return value; }\n\n    // ..........................................................\n    // BASIC REMOVES\n    // \n\n    test(\"remove a range after end of set\", function () {\n      equal(set.length, 0);\n\n      set.remove(1000, 5);\n      equal(set.length, 0);\n      equal(set.lastIndex, -1);\n      deepEqual(set.map(K), []);\n    });\n\n    test(\"remove range in middle of an existing range\", function () {\n      set.add(100, 4);\n      deepEqual(set.map(K), [100, 101, 102, 103]);\n\n      set.remove(101, 2);\n      equal(set.length, 2);\n      equal(set.lastIndex, 103);\n      deepEqual(set.map(K), [100, 103]);\n    });\n\n    test(\"remove range overlapping front edge of range\", function () {\n      set.add(100, 2);\n      equal(set.map(K)[0], 100);\n      \n      // remove half the range\n      set.remove(99, 2);\n      equal(set.length, 1);\n      equal(set.lastIndex, 101);\n      deepEqual(set.map(K), [101]);\n    });\n\n    test(\"remove range overlapping last edge of range\", function () {\n      set.add(100, 2)\n         .add(200, 2);\n\n      deepEqual(set.map(K), [100, 101, 200, 201]);\n      \n      // remove one part of the range\n      set.remove(101, 2);\n      equal(set.length, 3);\n      equal(set.lastIndex, 201);\n      deepEqual(set.map(K), [100, 200, 201]);\n    });\n\n    test(\"remove range overlapping two ranges, remove parts of both\", function () {\n      set.add(100, 2)\n         .add(110, 2);\n      deepEqual(set.map(K), [100, 101, 110, 111]);\n      \n      // remove a range that intersects both ranges\n      set.remove(101, 10);\n      equal(set.length, 2);\n      equal(set.lastIndex, 111);\n      deepEqual(set.map(K), [100, 111]);\n    });\n\n    test(\"remove range overlapping three ranges, removing one and parts of the others\", function () {\n      set.add(100, 2)\n         .add(105, 2)\n         .add(110, 2);\n\n      deepEqual(set.map(K), [100, 101, 105, 106, 110, 111]);\n      \n      // remove a range that intersects two ranges and overlaps one\n      set.remove(101, 10);\n      equal(set.length, 2);\n      equal(set.lastIndex, 111);\n      deepEqual(set.map(K), [100, 111]);\n    });\n\n    test(\"remove range partially overlapping one range and replacing another range\", function () {\n      set.add(100, 2)\n         .add(105, 2);\n\n      deepEqual(set.map(K), [100, 101, 105, 106]);\n      \n      // remove a part of one; and the rest of the other\n      set.remove(101, 10);\n      equal(set.length, 1);\n\n      equal(set.lastIndex, 100);\n      deepEqual(set.map(K), [100]);\n    });\n\n    test(\"remove range overlapping last index\", function () {\n      set.add(100, 2);\n      equal(set.map(K)[0], 100);\n      \n      // remove lastIndex\n      set.remove(101, 2);\n      equal(set.length, 1);\n      equal(set.lastIndex, 100);\n      deepEqual(set.map(K), [100]);\n    });\n\n    test(\"remove range matching existing range\", function () {\n      set.add(100, 5);\n      deepEqual(set.map(K), [100, 101, 102, 103, 104]);\n      \n      // remove complete range\n      set.remove(100, 5);\n      equal(set.length, 0);\n      equal(set.lastIndex, -1);\n      deepEqual(set.map(K), []);  \n    });\n\n    // ..........................................................\n    // NORMALIZED PARAMETER CASES\n    // \n\n    test(\"remove with no params should do nothing\", function () {\n      set.add(10, 2).remove();\n      deepEqual(set.map(K), [10, 11]);\n    });\n\n    test(\"remove with single number should add index only\", function () {\n      set.add(10, 2).remove(10);\n      deepEqual(set.map(K), [11]);\n    });\n\n    test(\"remove with index set should add indexes in set\", function () {\n      var otherSet = new IndexSet(2, 2);\n      otherSet.add(10, 2);\n\n      set.add(0, 14).remove(otherSet);\n      deepEqual(set.map(K), [0, 1, 4, 5, 6, 7, 8, 9, 12, 13]);\n    });\n\n\n    // ..........................................................\n    // OTHER BEHAVIORS\n    //\n\n    test(\"remove a range should trigger an observer notification\", function () {\n      var callCnt = 0;\n      set.add(10, 20);\n      \n      set.on(\'length:change\', null, function () { callCnt++; });\n      set.remove(10, 10);\n      equal(callCnt, 1, \'should have called observer once\');\n    });\n\n    test(\"removing a non-existent range should not trigger observer notification\", function () {\n      var callCnt = 0;\n      \n      set.on(\'length:change\', null, function () { callCnt++; });\n      set.remove(10, 10);\n      equal(callCnt, 0);\n    });\n\n    test(\"removing a clone of the same index set should leave an empty set\", function () {\n      var set  = new IndexSet(0, 2),\n          set2 = set.copy();\n\n      ok(set.equals(set2));\n      set.remove(set2);\n      equal(set.length, 0);\n    });\n\n    test(\"removing an index range outside of target range (specific bug)\", function () {\n      var set  = new IndexSet(10, 3),\n          set2 = new IndexSet(0, 3);\n      \n      set.remove(set2);\n      equal(set.length, 3, \'length should not change\');\n    });\n  });//# sourceURL=tests/index-set/remove.js");
